/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include "stm32f4xx.h"
#include "rtc_ds3231.h"
#include "oled_ssd1306.h"

#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "task.h"
#include "semphr.h"

//global handle for freertos
TaskHandle_t oled_task_t;
TaskHandle_t rtc_task_t;

SemaphoreHandle_t i2c_mutex;
SemaphoreHandle_t time_data_mutex;

rtc_time_t shared_time_data;

volatile uint8_t ds3231_seconds = 0;
volatile uint8_t ds3231_control = 0;
volatile uint8_t ds3231_status = 0;

void RTC_Task(void *P);
void OLED_Task(void *p);

static void delay_simple(volatile uint32_t count)
{
    while (count--) {
        __asm volatile ("nop");
    }
}

void ITM_print_time_with_day(uint8_t hour, uint8_t minute, uint8_t second, uint8_t day);



int main(void)
{
    gpio_init_i2c1_pins();
    i2c_init(I2C1);

    delay_simple(5000000U);

    // Try OLED init with debug
    ITM_SendChar('O');
    ITM_SendChar('L');
    ITM_SendChar('E');
    ITM_SendChar('D');
    ITM_SendChar('\n');

    ITM_SendChar('O');
    ITM_SendChar('K');
    ITM_SendChar('\n');

    delay_simple(1000000U);

    i2c_mutex = xSemaphoreCreateMutex();
    if(i2c_mutex == NULL){
        printf("i2c sema create failed");
        while(1);
    }

    time_data_mutex = xSemaphoreCreateMutex();
    if(time_data_mutex == NULL){
        printf("time data sema create failed");
        while(1);
    }

    xTaskCreate(OLED_Task, "oled", 512, NULL, 1, &oled_task_t);
    xTaskCreate(RTC_Task, "rtc", 256, NULL, 3, &rtc_task_t);

    vTaskStartScheduler();

    while (1) {}
    return 0;
}

void ITM_print_time_with_day(uint8_t hour, uint8_t minute, uint8_t second, uint8_t day)
{
    const char* day_names[] = {
        "---", "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"
    };

    char buf[32];
    int idx = 0;

    const char* day_str = (day >= 1 && day <= 7) ? day_names[day] : day_names[0];
    for (int i = 0; day_str[i] != '\0'; i++) {
        buf[idx++] = day_str[i];
    }

    buf[idx++] = ' ';

    /* Add time */
    buf[idx++] = (char)('0' + (hour / 10));
    buf[idx++] = (char)('0' + (hour % 10));
    buf[idx++] = ':';
    buf[idx++] = (char)('0' + (minute / 10));
    buf[idx++] = (char)('0' + (minute % 10));
    buf[idx++] = ':';
    buf[idx++] = (char)('0' + (second / 10));
    buf[idx++] = (char)('0' + (second % 10));
    buf[idx++] = '\r';
    buf[idx++] = '\n';

    /* Send to ITM */
    for (int i = 0; i < idx; i++) {
        ITM_SendChar(buf[i]);
    }
}

void RTC_Task(void *P){
    TickType_t last_wake_time;
    rtc_time_t temp_time;
    BaseType_t mutex_result;
    uint8_t consecutive_failures = 0;

    last_wake_time = xTaskGetTickCount();

    while(1){
        // Try to get mutex with reasonable timeout
        mutex_result = xSemaphoreTake(
            i2c_mutex,
            pdMS_TO_TICKS(100)      // Back to 100ms - we'll retry if needed
        );

        if(mutex_result != pdTRUE) {
            ITM_SendChar('E');
            ITM_SendChar('1');
            ITM_SendChar('\n');

            consecutive_failures++;

            if(consecutive_failures >= 5) {
                // Try recovery with longer timeout
                mutex_result = xSemaphoreTake(i2c_mutex, pdMS_TO_TICKS(1000));
                if(mutex_result == pdTRUE) {
                    i2c_bus_recovery(I2C1);
                    xSemaphoreGive(i2c_mutex);
                }
                consecutive_failures = 0;
            }

            vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));
            continue;
        }

        // === GOT MUTEX - READ RTC QUICKLY ===
        if (rtc_read_time(&temp_time) != 0) {
            ITM_SendChar('R');
            ITM_SendChar('F');   // RTC fail
            ITM_SendChar('\n');

            xSemaphoreGive(i2c_mutex);
            vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));
            continue;
        }

        // === RELEASE IMMEDIATELY ===
        xSemaphoreGive(i2c_mutex);

        consecutive_failures = 0;

        // Now update shared data (no I2C needed)
        mutex_result = xSemaphoreTake(time_data_mutex, pdMS_TO_TICKS(50));

        if(mutex_result == pdTRUE){
            shared_time_data.hours = temp_time.hours;
            shared_time_data.minutes = temp_time.minutes;
            shared_time_data.seconds = temp_time.seconds;
            shared_time_data.day = temp_time.day;
            shared_time_data.date = temp_time.date;
            shared_time_data.month = temp_time.month;
            shared_time_data.year = temp_time.year;

            xSemaphoreGive(time_data_mutex);
        }
        else {
            ITM_SendChar('E');
            ITM_SendChar('2');
            ITM_SendChar('\n');
        }

        // Notify OLED
        xTaskNotifyGive(oled_task_t);

        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));
    }
}

void OLED_Task(void *P){
	  rtc_time_t local_time_copy;
	    uint32_t notification_value;
	    BaseType_t mutex_result;

	    // === ONE-TIME OLED INITIALIZATION ===
	    mutex_result = xSemaphoreTake(i2c_mutex, pdMS_TO_TICKS(1000));

	    if(mutex_result == pdTRUE) {
	           ITM_SendChar('O');
	           ITM_SendChar('I');
	           ITM_SendChar('\n');

	           ssd1306_init();
	           ssd1306_clear();
	           ssd1306_update();

	           ITM_SendChar('O');
	           ITM_SendChar('K');
	           ITM_SendChar('\n');

	           xSemaphoreGive(i2c_mutex);
	       }
	       else {
	           ITM_SendChar('E');
	           ITM_SendChar('3');
	           ITM_SendChar('\n');
	       }

	       // Add small delay to let RTC task start
	       vTaskDelay(pdMS_TO_TICKS(100));
	    while(1)
	     {
	         // === STEP 1: WAIT FOR NOTIFICATION ===
	         notification_value = ulTaskNotifyTake(
	             pdTRUE,                 // Clear notification on exit
	             pdMS_TO_TICKS(2000)     // 2 second timeout
	         );

	         if(notification_value == 0) {
	             // Timeout - no notification received
	             ITM_SendChar('W');
	             ITM_SendChar('1');
	             ITM_SendChar('\n');
	             continue;
	         }

	         // === STEP 2: READ SHARED DATA ===
	         mutex_result = xSemaphoreTake(
	             time_data_mutex,
	             pdMS_TO_TICKS(50)
	         );

	         if(mutex_result != pdTRUE) {
	             // Data mutex timeout
	             ITM_SendChar('E');
	             ITM_SendChar('4');
	             ITM_SendChar('\n');
	             continue;
	         }

	         // Copy to local variable
	         local_time_copy.hours = shared_time_data.hours;
	         local_time_copy.minutes = shared_time_data.minutes;
	         local_time_copy.seconds = shared_time_data.seconds;
	         local_time_copy.day = shared_time_data.day;
	         local_time_copy.date = shared_time_data.date;
	         local_time_copy.month = shared_time_data.month;
	         local_time_copy.year = shared_time_data.year;

	         xSemaphoreGive(time_data_mutex);

	         // === STEP 3: PREPARE FRAMEBUFFER (NO I2C) ===
	         draw_time_with_day_on_oled(
	             local_time_copy.hours,
	             local_time_copy.minutes,
	             local_time_copy.seconds,
	             local_time_copy.day
	         );

	         // === STEP 4: UPDATE DISPLAY ===
	         mutex_result = xSemaphoreTake(
	             i2c_mutex,
	             pdMS_TO_TICKS(500)
	         );

	         if(mutex_result != pdTRUE) {
	             // I2C mutex timeout
	             ITM_SendChar('E');
	             ITM_SendChar('5');
	             ITM_SendChar('\n');
	             continue;
	         }

	         ssd1306_update();
	         xSemaphoreGive(i2c_mutex);

	         // === STEP 5: DEBUG OUTPUT ===
	         ITM_print_time_with_day(
	             local_time_copy.hours,
	             local_time_copy.minutes,
	             local_time_copy.seconds,
	             local_time_copy.day
	         );
	     }
	 }

